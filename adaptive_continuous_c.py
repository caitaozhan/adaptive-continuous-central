'''The centralized version of AC Protocol
'''

from enum import Enum, auto
from dataclasses import dataclass
from collections import defaultdict
from typing import TYPE_CHECKING, List, DefaultDict, Optional
from networkx.classes.graph import Graph
from itertools import accumulate
from bisect import bisect_left

from sequence.network_management.reservation import Reservation
from sequence.kernel.process import Process
from sequence.kernel.event import Event
from sequence.components.memory import Memory
from sequence.utils import log
from sequence.message import Message
from sequence.protocol import Protocol
from sequence.constants import SECOND
from sequence.resource_management.memory_manager import MemoryManager
from reservation import ResourceReservationProtocolAdaptive, ReservationAdaptive
from purification import BBPSSW_bds


if TYPE_CHECKING:
    from node import QuantumRouterAdaptiveWorker
    from controller import Controller
    from sequence.resource_management.rule_manager import Rule
    from resource_manager import ResourceManagerAdaptive


class ACMsgType(Enum):
    '''Defines possible message types between the adaptive controller and the workers, and between the workers
    '''
    UPDATE_PROB_TABLE = auto()  # controller -> worker, update the probability table
    REQUEST = auto()    # ask if the neighbor has available memory
    RESPOND = auto()    # responding NO/YES
    EXPIRE  = auto()    # expire the rules generated by the requests when the requests are served before the end_time (not related to AC protocol)
    INFORM_EP = auto()  # for creating entanglement purification protocol


class AdaptiveContinuousMessage(Message):
    '''Message between the adaptive continuous controller and the workers, and between the workers
    '''
    def __init__(self, msg_type: ACMsgType, **kwargs):
        super().__init__(msg_type, receiver='adaptive_continuous')
        self.string = f'type={msg_type.name}'
        
        if self.msg_type == ACMsgType.UPDATE_PROB_TABLE:
            self.probability_table = kwargs['probability_table']
            self.string += f', probability_table={self.probability_table}'
        elif self.msg_type == ACMsgType.REQUEST:
            self.reservation = kwargs['reservation']
            self.string += f', reservation={self.reservation}'
        elif self.msg_type == ACMsgType.RESPOND:
            self.reservation = kwargs['reservation']
            self.string += f', reservation={self.reservation}'
            self.answer = kwargs['answer']
            self.string += f', answer={self.answer}'
            if self.answer == True:
                self.path = kwargs['path']
                self.string += f', path={self.path}'
        elif self.msg_type == ACMsgType.INFORM_EP:
            self.selected_ep = kwargs['selected_ep']
            self.rule = kwargs['rule']
            self.string += f', selected_ep={self.selected_ep}'
        elif self.msg_type == ACMsgType.EXPIRE:
            self.reservation = kwargs['reservation']
            self.string += f', reservation={self.reservation}'

    def __str__(self):
        return f'|{self.string}|'


@dataclass
class ProbabilityTable:
    """The probability table for all nodes in the network within a time range.

    Attribute:
        start_time (float): the starting time (s)
        end_time (float): the ending time (s)
        probability_table_dict (DefaultDict[str, dict]): router_name -> dictionary[neighbor_name, probability]
    """
    start_time: float = -1
    end_time: float = -1
    probability_table_dict: DefaultDict[str, dict] = None



class AdaptiveContinuousController(Protocol):
    """The central controller of the adaptive continuous entanglement generation.
    There is only controller for the whole quantum network. Located at one arbitrary node.
    """
    def __init__(self, owner: "Controller", name: str):
        super().__init__(owner, name)
        self.graph: Graph = None   # the network graph/topology
        self.traffic: list = None  # a list of tuples of (matrix, start_time, end_time)
        self.probability_tables: List[ProbabilityTable] = []

    def init(self, graph: Graph, traffic: defaultdict[str, dict]):
        """Initialize the graph and traffic matrix

        Args:
            graph: the network graph, i.e., topology
            traffic:  # a list of tuples of (matrix, start_time, end_time) 
        """
        self.set_graph(graph)
        self.set_traffic(traffic)

    def set_graph(self, graph: Graph):
        """set the graph, i.e., topology

        Attributes:
            graph: the graph that saves the topology data
        """
        self.graph = graph

    def set_traffic(self, traffic: list):
        """Set the traffic

        Args:
            traffic: a list of tuples of (matrix, start_time, end_time)
        """
        self.traffic = traffic

    def init_prob_tables(self):
        """Initiate the probabilty tables for each traffic matrix
        """
        if self.graph is not None and self.traffic is not None:
            for matrix, start_time, end_time in self.traffic:
                probability_table = self.compute_probability_table_uniform(matrix, start_time, end_time)
                self.probability_tables.append(probability_table)


    def send_probability_table(self):
        """schedule events to send messages to the nodes to update the probability table
        """
        for probability_table in self.probability_tables:
            start_time = probability_table.start_time * SECOND
            end_time = probability_table.end_time * SECOND
            probability_table_dict = probability_table.probability_table_dict
            for node, probability_table in probability_table_dict.items():
                msg = AdaptiveContinuousMessage(ACMsgType.UPDATE_PROB_TABLE, probability_table=probability_table)
                process = Process(self.owner, 'send_message', [node, msg])
                event = Event(start_time, process)
                self.owner.timeline.schedule(event)
                # reset at end_time
                msg = AdaptiveContinuousMessage(ACMsgType.UPDATE_PROB_TABLE, probability_table=None)
                process = Process(self.owner, 'send_message', [node, msg])
                event = Event(end_time, process)
                self.owner.timeline.schedule(event)


    def compute_probability_table_uniform(self, matrix: List[List], start_time: float, end_time: float) -> ProbabilityTable:
        """Create a uniform probability table for each node

        Args:
            matrix: the traffic matrix
            start_time: the start time of the matrix (s)        
            end_time: the end time of the matrix (s)        
        """
        probability_table = defaultdict(dict)
        # 1. create the graph
        g = defaultdict(list)
        for edge in self.graph.edges:
            u, v = edge
            g[u].append(v)
            g[v].append(u)
        # 2. create the probability table
        for node in g:
            neighbors = g[node]
            p = 1 / (len(neighbors) + 1)
            node_probility_table = {}
            for neighbor in neighbors:
                node_probility_table[neighbor] = p
            node_probility_table[''] = p
            probability_table[node] = node_probility_table
        # 3. return the desired object
        probability_table = ProbabilityTable(start_time, end_time, probability_table)
        return probability_table


    def received_message(self, src, msg):
        """Receive classical message from another node."""
        pass



class AdaptiveContinuousWorker(Protocol):
    """The worker of the adaptive continuous entanglement generation.
    If not the controller, the rest of the nodes are all workers.
    """
    def __init__(self, owner: "QuantumRouterAdaptiveWorker", name: str, adaptive_max_memory: int, resource_reservation: ResourceReservationProtocolAdaptive, period: int = SECOND):
        super().__init__(owner, name)
        self.adaptive_max_memory = adaptive_max_memory
        self.adaptive_memory_used = 0
        self.resource_reservation = resource_reservation
        self.probability_table = {}
        self.generated_entanglement_pairs = set()
        self.strategy = 'freshest'
        self.period = period
        self.delay_no_memory = 0             # this node either reached adaptive_max_memory or no memory 
        self.delay_select_neighbor_none = 0  # this node selected none as neighbor
        self.delay_remote_response = 0       # neighbor has a response
        self.update_period(period)

    def received_message(self, src: str, msg: AdaptiveContinuousMessage):
        """Receive classical message from another node.
        """
        log.logger.debug('{} receive message from {}: {}'.format(self.owner.name, src, msg))

        if msg.msg_type is ACMsgType.UPDATE_PROB_TABLE:
            if msg.probability_table is not None:
                self.probability_table = msg.probability_table
            else:
                self.init()

        elif msg.msg_type is ACMsgType.REQUEST:
            if self.adaptive_memory_used >= self.adaptive_max_memory:
                new_msg = AdaptiveContinuousMessage(ACMsgType.RESPOND, reservation=msg.reservation, answer=False)
                log.logger.debug(f'{self.owner.name} adaptive_memory_used reached the maximum')
            else:
                reservation: ReservationAdaptive = msg.reservation
                if self.resource_reservation.schedule(reservation):
                    log.logger.debug(f'{self.owner.name} adaptive_memory_used is increased from {self.adaptive_memory_used} to {self.adaptive_memory_used+1}')
                    self.adaptive_memory_used += 1
                    path = [src, self.owner.name]
                    rules = self.resource_reservation.create_rules_adaptive(path, reservation)
                    self.resource_reservation.load_rules_adaptive(rules, reservation)
                    reservation.set_path(path)
                    new_msg = AdaptiveContinuousMessage(ACMsgType.RESPOND, reservation=msg.reservation, answer=True, path=path)
                else:
                    new_msg = AdaptiveContinuousMessage(ACMsgType.RESPOND, reservation=msg.reservation, answer=False)
            self.owner.send_message(src, new_msg)
        
        elif msg.msg_type is ACMsgType.RESPOND:
            if msg.answer is False:              # neighbor doesn't has available memory
                for card in self.resource_reservation.timecards:
                    card.remove(msg.reservation) # clear up the timecards
                log.logger.debug(f'{self.owner.name} not going to establish entanglement link {self.owner.name}-{src}; adaptive_memory_used is decreased from {self.adaptive_memory_used} to {self.adaptive_memory_used - 1}')
                self.adaptive_memory_used -= 1
            else:                                # neighbor has available timecards
                rules = self.resource_reservation.create_rules_adaptive(msg.path, msg.reservation)
                self.resource_reservation.load_rules_adaptive(rules, msg.reservation)
                log.logger.info(f'{self.owner.name} attempting to establish entanglement link {self.owner.name}-{src}')
            self.start_delay(delay=self.delay_remote_response)                

        elif msg.msg_type is ACMsgType.EXPIRE:
            # This job should be done by the resource manager. 
            # Didn't do it because of not wanting to add a Message type in the Resource Manager
            reservation = msg.reservation
            resource_manager = self.get_resource_manager()
            resource_manager.expire_rules_by_reservation(reservation)

        elif msg.msg_type is ACMsgType.INFORM_EP:
            # This job should be done by the resource manager (rules generate protocols)
            # Didn't do it because didn't want to add a Message type in the Resource Manager
            # create the purification protocol.
            entanglement_pair, entanglement_pair2 = msg.selected_ep  # ((node_name, memory_name), (remote_node_name, remote_memory_name))
            rule = msg.rule
            if rule in rule.rule_manager.rules:   # AC Protocol expired while the message is traveling in the air
                entanglement_pair  = (entanglement_pair[1],  entanglement_pair[0])  # remote node to local node
                entanglement_pair2 = (entanglement_pair2[1], entanglement_pair2[0])
                self.remove_entanglement_pair(entanglement_pair)
                self.remove_entanglement_pair(entanglement_pair2)
                purification_protocol = self.create_purification_protocol(entanglement_pair, entanglement_pair2, rule)
                self.owner.protocols.append(purification_protocol)
                if purification_protocol.is_ready():
                    purification_protocol.start()
                else:
                    raise Exception('Program should not run here')
            else:
                log.logger.info(f'Rule expired: {rule}')


    def init(self):
        """Initialize the AC worker, i.e., do not se
        """
        self.probability_table[''] = 1


    def update_period(self, period: int) -> None:
        '''update the period of ACP, and also update the delays

        Args:
            period (int): time in ps
        '''
        self.period = period
        self.delay_no_memory            = period // 1000
        self.delay_select_neighbor_none = period // 100
        self.delay_remote_response      = 3 * self.delay_no_memory


    def start_delay(self, delay: float) -> None:
        '''create a "start" event after a random delay between [0, delay]
        Args:
            delay: schedule the event after some amount of delay (pico seconds) between 0 and delay
        '''
        if self.adaptive_max_memory > 0:      # only start if AC protocol is assigned some memories
            assert delay >= 0, f'delay = {delay} is negative'
            random_delay = int(self.owner.get_generator().uniform(0, delay))
            process = Process(self, 'start', [])
            event = Event(self.owner.timeline.now() + random_delay, process)
            self.owner.timeline.schedule(event)

    def start(self) -> None:
        '''start a new "cycle" of the adaptive-continuous protocol
        '''
        # check whether the adaptive protocol has used up its memory quota
        if self.adaptive_memory_used >= self.adaptive_max_memory:
            self.start_delay(delay = self.delay_no_memory)  # schedule a start event in the future
            return

        # select neighbor
        neighbor = self.select_neighbor()
        if neighbor == '':
            log.logger.debug(f'{self.owner.name} selected neighbor None')
            self.start_delay(delay = self.delay_select_neighbor_none)  # schedule a start event in the future
            return

        log.logger.debug(f'{self.owner.name} selected neighbor {neighbor}, adaptive_memory_used is increased from {self.adaptive_memory_used} to {self.adaptive_memory_used + 1}')
        self.adaptive_memory_used += 1
        round_trip_time = self.owner.cchannels[neighbor].delay * 2
        start_time = self.owner.timeline.now() + round_trip_time    # consider a round trip time for the "handshaking"
        end_time = self.round_to_period(start_time + self.period)   # the 'period' is one second
        # set up reservation
        reservation = ReservationAdaptive(self.owner.name, neighbor, start_time, end_time, memory_size=1, fidelity=0.9)
        if self.resource_reservation.schedule(reservation):
            # able to schedule on current node, i.e., has memory
            msg = AdaptiveContinuousMessage(ACMsgType.REQUEST, reservation=reservation)
            self.owner.send_message(neighbor, msg)
        else:
            # not able to schedule on current node (lack of memory), schedule another start event after 1 ms
            self.adaptive_memory_used -= 1
            self.start_delay(delay = self.delay_no_memory)


    def select_neighbor(self) -> str:
        '''return the name of the selected neighbor
           The selection algorithm is roulette wheel
        '''
        neighbors = []
        probs = []
        for neighbor, prob in sorted(self.probability_table.items()):
            neighbors.append(neighbor)
            probs.append(prob)
        probs_accumulate = list(accumulate(probs))
        random_number = self.owner.get_generator().random()
        index = bisect_left(probs_accumulate, random_number)
        neighbor = neighbors[index]
        return neighbor

    def round_to_period(self, time: int) -> int:
        '''if period is 1 second, then turn 1.001 second into 1 second
        
        Args:
            time: in picoseconds
        '''
        return (time // self.period) * self.period

    def remove_entanglement_pair(self, entanglement_pair: tuple):
        '''remove an entanglement_pair because it is used
        
        Side Effect:
            Will raise Exception when the entanglement_pair doesn't exist. 
            It will happen when an expire event happend in the middle of a swap memory protocol, which takes 2 ms long
        '''
        entanglement_pair2 = (entanglement_pair[1], entanglement_pair[0])
        if entanglement_pair in self.generated_entanglement_pairs:
            self.generated_entanglement_pairs.remove(entanglement_pair)
            log.logger.info(f'{self.owner.name} removed EP {entanglement_pair}')
        elif entanglement_pair2 in self.generated_entanglement_pairs:
            self.generated_entanglement_pairs.remove(entanglement_pair2)
            log.logger.info(f'{self.owner.name} removed EP {entanglement_pair2}')
        else:
            raise Exception(f"{entanglement_pair} doesn't exist in {self.name}")


    def create_purification_protocol(self, entanglement_pair: tuple, entanglement_pair2: tuple, rule: "Rule") -> BBPSSW_bds:
        '''given two entanglement pairs, create the purification protocol and pair it directly 
        (instead of creating the purification through rules and pairing in the resource management)
        
        Args:
            entanglement_pair (tuple):  ((node_name, memory_name), (remote_node_name, remote_memory_name))
            entanglement_pair2 (tuple): ((node_name, memory_name), (remote_node_name, remote_memory_name))
            rule (Rule): the rule that the purification is associated with, this rule should be eg_rule_action_adaptive, when it expires, it will remove the purification from self.owner.protocols
        Return:
            BBPSSW_bds: the purification protocol
        '''
        assert entanglement_pair[0][0] == entanglement_pair2[0][0], 'this node does not match'
        assert entanglement_pair[1][0] == entanglement_pair2[1][0], 'remote node does not match'
        # this_node_name    = entanglement_pair[0][0]
        this_memory1_name = entanglement_pair[0][1]
        this_memory2_name = entanglement_pair2[0][1]
        remote_node_name    = entanglement_pair2[1][0]
        remote_memory1_name = entanglement_pair[1][1]
        remote_memory2_name = entanglement_pair2[1][1]
        name = "EP_bds.{}.{}".format(this_memory1_name, this_memory2_name)
        this_memory1: Memory = self.owner.timeline.get_entity_by_name(this_memory1_name)  # kept memory
        this_memory2: Memory = self.owner.timeline.get_entity_by_name(this_memory2_name)  # meas memory
        purification_protocol = BBPSSW_bds(self.owner, name, this_memory1, this_memory2)
        # update memory observer and memory info
        this_memory1.detach(this_memory1.memory_array)   # set observer
        this_memory1.attach(purification_protocol)
        this_memory2.detach(this_memory2.memory_array)
        this_memory2.attach(purification_protocol)
        memory_manager = self.get_memory_manager()
        this_info1 = memory_manager.get_info_by_memory(this_memory1)
        this_info2 = memory_manager.get_info_by_memory(this_memory2)
        this_info1.to_occupied()                         # set memory_info to occupied
        this_info2.to_occupied()
        remote_protocol_name = "EP_bds.{}.{}".format(remote_memory1_name, remote_memory2_name)
        memories = [remote_memory1_name, remote_memory2_name]
        purification_protocol.set_others(remote_protocol_name, remote_node_name, memories)
        purification_protocol.rule = rule
        rule.protocols.append(purification_protocol)  # when the rule expires, it clears this purification protocol
        return purification_protocol

    def get_memory_manager(self) -> MemoryManager:
        '''get the memory manager that is associated to self.owner
        '''
        return self.owner.resource_manager.memory_manager

    def get_resource_manager(self) -> "ResourceManagerAdaptive":
        return self.owner.resource_manager
    
    def add_generated_entanglement_pair(self, entanglement_pair: tuple):
        '''track the new entanglement pair generated by the Adaptive Continuous protocol
        Args:
            entanglement_link: Tuple[(node_name, memory_name), (remote_node_name, remote_memory_name)]
        '''
        if entanglement_pair not in self.generated_entanglement_pairs:
            self.generated_entanglement_pairs.add(entanglement_pair)
            log.logger.info(f'{self.owner.name} added EP {entanglement_pair}')
        else:
            log.logger.warning(f'{self.owner.name} EP {entanglement_pair} already exist')


    def match_generated_entanglement_pair(self, this_node_name: str, remote_node_name: str) -> Optional[tuple]:
        '''match (this_node_name, remote_node_name) to an existing entanglement pair
        
        Return:
            Tuple[(node_name, memory_name), (remote_node_name, remote_memory_name)] -- the freshest entanglement pair
            None -- if no match exist
        '''
        entanglement_pairs = []
        for entanglement_pair in sorted(self.generated_entanglement_pairs):
            ent_this_node_name   = entanglement_pair[0][0]
            ent_remote_node_name = entanglement_pair[1][0]
            if ent_this_node_name == this_node_name and ent_remote_node_name == remote_node_name:
                entanglement_pairs.append(entanglement_pair)
        
        if len(entanglement_pairs) == 0:
            return None

        if self.strategy == "random":
            return entanglement_pairs[0]
        elif self.strategy == "freshest":
            freshest_ep = None
            best_fidelity = 0
            for ep in entanglement_pairs:
                fidelity = self.get_fidelity(ep)
                if fidelity > best_fidelity:
                    freshest_ep = ep
                    best_fidelity = fidelity
            return freshest_ep
        else:
            raise Exception(f'{self.strategy} not supported')


    def get_fidelity(self, entanglement_pair: tuple) -> float:
        '''
        Args:
            entanglement_pair (tuple): the entanglement pair created by the ACP, ((node_name, memory_name), (remote_node_name, remote_memory_name))
        Return:
            float: the fidelity of the entanglement pair, will update the fidelity
        '''
        local_memory_name  = entanglement_pair[0][1]
        remote_memory_name = entanglement_pair[1][1]
        local_memory: Memory = self.owner.timeline.get_entity_by_name(local_memory_name)
        remote_memory: Memory = self.owner.timeline.get_entity_by_name(remote_memory_name)
        local_memory.bds_decohere()
        remote_memory.bds_decohere()
        return local_memory.get_bds_fidelity()


    def get_entanglement_pair2(self, entanglement_pair: tuple) -> Optional[tuple]:
        '''given an entanglement_pair, find an other entanglement_pair between the same two nodes (for purification). 
           Both two nodes select the EP whose fidelity is the closest.
        
        Args:
            entanglement_pair (tuple): the entanglement pair created by the ACP, ((node_name, memory_name), (remote_node_name, remote_memory_name))
        Return:
            entanglement_pair or None
        '''
        this_fidelity = 0
        eps = []
        this_node  = entanglement_pair[0][0]
        other_node = entanglement_pair[1][0]
        for ep in self.generated_entanglement_pairs:
            if ep == entanglement_pair:
                this_fidelity = self.get_fidelity(ep)
            else:
                if ep[0][0] == this_node and ep[1][0] == other_node:
                    eps.append(ep)

        if eps:
            closest_ep = None
            fidelity_difference = 1
            for ep in eps:
                fidelity = self.get_fidelity(ep)
                difference = abs(this_fidelity - fidelity)
                if difference < fidelity_difference:
                    closest_ep = ep
                    fidelity_difference = difference
            return closest_ep
        else:
            return None


    def adaptive_memory_used_minus_one(self, memory: Memory) -> None:
        '''reduce the self.adaptive_memory_used by 1. Called right after the entanglement generation protocol is expired
        Args:
            memory: this is the memory that is set to RAW (due to expired rule), released from the adaptive continuous protocol
        '''
        assert self.adaptive_memory_used > 0, f"{self.owner.name} adaptive_memory_used={self.adaptive_memory_used}"
        self.adaptive_memory_used -= 1
        log.logger.debug(f'{self.owner.name} adaptive_memory_used is reduced from {self.adaptive_memory_used + 1} to {self.adaptive_memory_used}')
        # remove the entanglement pair that memory is in
        ep_to_delete = None
        for entanglement_pair in self.generated_entanglement_pairs:
            if entanglement_pair[0][1] == memory.name:
                ep_to_delete = entanglement_pair
                break
            elif entanglement_pair[1][1] == memory.name:
                ep_to_delete = entanglement_pair
                break
        if ep_to_delete is None:  # the entanglement pair that includes argument memory doesn't exist, because the EP generation is not successfull yet
            log.logger.info(f'{self.owner.name} {memory.name} is not found in self.generated_entanglement_pairs!')
        else:
            self.generated_entanglement_pairs.remove(ep_to_delete)
            log.logger.info(f'{self.owner.name} removed EP {ep_to_delete}')

    def send_expire_rules_message(self, node: str, reservation: Reservation) -> None:
        '''send messages to node to expire the rules generated by reseravation

        Args:
            node: send message to this node
            reseravation: the rules generated by this reservation (from request) will expire
        '''
        msg = AdaptiveContinuousMessage(ACMsgType.EXPIRE, reservation=reservation)
        self.owner.send_message(node, msg)
